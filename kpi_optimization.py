# -*- coding: utf-8 -*-
"""KPI_optimization.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JHqmhjcx__tlkwaHlzvq5mYNKYmSOqUP
"""


import pulp
import numpy as np


def epsilon_constraint_allocation(effect_matrix, y_base, budget, epsilons):
    m, n = effect_matrix.shape
    solutions = {}

    for target in range(m):
        model = pulp.LpProblem(f"Maximize_KPI_{target}", pulp.LpMaximize)

        # 施策ごとの予算配分変数
        x = [pulp.LpVariable(f"x_{i}", lowBound=0) for i in range(n)]

        # KPI予測値 = 直近KPI + 効果行列 @ 配分
        y = [y_base[k] + pulp.lpSum(effect_matrix[k][i]*x[i] for i in range(n)) for k in range(m)]

        # 総予算制約
        model += pulp.lpSum(x) == budget

        # ε制約（ターゲット以外のKPIは下限確保）
        for k in range(m):
            if k != target:
                model += y[k] >= epsilons[k]

        # 目的関数: ターゲットKPI最大化
        model += y[target]

        # 解く
        model.solve(pulp.PULP_CBC_CMD(msg=0))

        # 結果取得
        x_sol = [round(pulp.value(var),4) for var in x]
        y_sol = [round(pulp.value(val), 4) for val in y]

        solutions[target] = {"allocation": x_sol, "KPI_pred": y_sol}

    return solutions

# ==== テストデータ ====
np.random.seed(42)
m, n = 3, 3  # KPI3個, 施策3個

effect_matrix = np.random.uniform(0.5, 1.5, (m, n))
y_base = np.random.uniform(40, 50, m)
budget = 20
epsilons = [60, 70, 70]

solutions = epsilon_constraint_allocation(effect_matrix, y_base, budget, epsilons)

for target, sol in solutions.items():
    print(f"=== Maximize KPI {target} ===")
    print("予算配分:", sol['allocation'])
    print("KPI予測値:", sol['KPI_pred'])
    print()

#mount
from google.colab import drive
drive.mount('/content/drive')

# Fixed, self-contained script that generates a ternary-style heatmap **without** requiring the `ternary` library.
# It uses pure matplotlib and a barycentric→Cartesian transform so it runs in this environment.
# The heatmap shows, for each budget split (x0, x1, x2), the *minimum* KPI increase rate (%) across the three KPIs.
#
# Notes:
# - One figure (no subplots), default matplotlib styling, and no explicit color selection (per your requirements).
# - Output file is saved to /mnt/data/ternary_heatmap.png

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.tri as mtri

# ---- Problem setup (as provided) ----
effect_matrix = np.array([
    [0.2, 0.2, 0.3],  # KPI 0
    [0.3, 0.3, 0.2],  # KPI 1
    [0.2, 0.1, 0.4],  # KPI 2
    [0.1, 0.3, 0.5]   # KPI 3
])
y_base = np.array([10, 20, 15, 25])
budget = 130

def get_min_kpi_rate(x0, x1, x2):
    """Return the minimum increase rate (%) across 3 KPIs for allocation (x0, x1, x2)."""
    allocation = np.array([x0, x1, x2])
    kpi_increase = np.dot(effect_matrix, allocation)                # absolute increase
    increase_rate = kpi_increase / y_base                           # fractional increase
    return float(np.min(increase_rate) * 100.0)                     # convert to %

# ---- Generate barycentric grid over the simplex ----
scale = 100  # resolution of the simplex grid (higher => smoother heatmap)
coords_bary = []  # (i, j, k) with i + j + k = scale
values = []       # min increase rate (%) for each point

for i in range(scale + 1):
    for j in range(scale - i + 1):
        k = scale - i - j
        # Convert the discrete shares into actual budget
        b0 = (i / scale) * budget
        b1 = (j / scale) * budget
        b2 = (k / scale) * budget
        coords_bary.append((i, j, k))
        values.append(get_min_kpi_rate(b0, b1, b2))

coords_bary = np.array(coords_bary, dtype=float)
values = np.array(values, dtype=float)

# ---- Barycentric → Cartesian for an equilateral triangle ----
# Vertices (x, y): v0 = (0, 0), v1 = (1, 0), v2 = (0.5, sqrt(3)/2)
v0 = np.array([0.0, 0.0])
v1 = np.array([1.0, 0.0])
v2 = np.array([0.5, np.sqrt(3)/2.0])

# Normalize to shares
shares = coords_bary / scale  # (s0, s1, s2), sum=1
# Barycentric combination
xy = shares[:, 0:1] * v0 + shares[:, 1:2] * v1 + shares[:, 2:3] * v2
x = xy[:, 0]
y = xy[:, 1]

# ---- Triangulate and plot a smooth heatmap ----
tri = mtri.Triangulation(x, y)

fig = plt.figure(figsize=(8, 6))
# tripcolor produces a heatmap over the triangulated points; no colormap specified (defaults used)
tpc = plt.tripcolor(tri, values, shading='gouraud')

# Draw the triangle boundary
plt.plot([v0[0], v1[0]], [v0[1], v1[1]])
plt.plot([v1[0], v2[0]], [v1[1], v2[1]])
plt.plot([v2[0], v0[0]], [v2[1], v0[1]])

# Corner labels for axes (corresponding to allocations)
plt.text(v0[0] - 0.03, v0[1] - 0.03, r"policy1", ha='right', va='top')
plt.text(v1[0] + 0.01, v1[1] - 0.03, r"policy2", ha='left',  va='top')
plt.text(v2[0],        v2[1] + 0.025, r"policy3", ha='center', va='bottom')

# Title and colorbar
plt.title("Budget distribution & min KPI increase rate")
cbar = plt.colorbar(tpc)
cbar.set_label("Minimum KPI Increase Rate (%)")

plt.axis('off')  # cleaner triangular plot
out_path = "/content/drive/Shareddrives/ぎょうせい/ternary_heatmap.png"
plt.tight_layout()
plt.savefig(out_path, dpi=200, bbox_inches='tight')
out_path